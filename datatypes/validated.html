<html><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><title>Cats</title><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="description" content="Lightweight, modular, and extensible library for functional programming" /><meta name="author" content="Typelevel contributors" /><meta name="og:image" content="/cats/img/poster.png" /><meta name="og:title" content="Cats" /><meta name="og:site_name" content="Cats" /><meta name="og:url" content="http://typelevel.org/cats" /><meta name="og:type" content="website" /><meta name="og:description" content="Lightweight, modular, and extensible library for functional programming" /><meta name="twitter:image" content="/cats/img/poster.png" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:site" content="" /><link rel="icon" type="image/png" href="/cats/img/favicon.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/atom-one-light.min.css" /><link rel="stylesheet" href="/cats/css/style.css" /><link rel="stylesheet" href="/cats/css/palette.css" /><link rel="stylesheet" href="/cats/css/override.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/cats/" class="brand"><div class="brand-wrapper" style="background:url('/cats/img/sidebar_brand.png') no-repeat"><span>Cats</span></div></a></li> </li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li class="hidden-xs"><a href="https://github.com/typelevel/cats"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li class="hidden-xs"><a href="https://github.com/typelevel/cats"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('Cats Lightweight, modular, and extensible library for functional programming');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('Cats Lightweight, modular, and extensible library for functional programming');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="typelevel" data-github-repo="cats"><div class="content-wrapper"><section><h1 id="validated">Validated</h1>

<p>Imagine you are filling out a web form to signup for an account. You input your username and password and submit.
Response comes back saying your username can’t have dashes in it, so you make some changes and resubmit. Can’t
have special characters either. Change, resubmit. Passwords need to have at least one capital letter. Change,
resubmit. Password needs to have at least one number.</p>

<p>Or perhaps you’re reading from a configuration file. One could imagine the configuration library you’re using returns
a <code class="highlighter-rouge">scala.util.Try</code>, or maybe a <code class="highlighter-rouge">scala.util.Either</code>. Your parsing may look something like:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="n">url</span>  <span class="k">&lt;-</span> <span class="n">config</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"url"</span><span class="o">)</span>
  <span class="n">port</span> <span class="k">&lt;-</span> <span class="n">config</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"port"</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="nc">ConnectionParams</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span>
</code></pre>
</div>

<p>You run your program and it says key “url” not found, turns out the key was “endpoint”. So you change your code
and re-run. Now it says the “port” key was not a well-formed integer.</p>

<p>It would be nice to have all of these errors be reported simultaneously. That the username can’t have dashes can
be validated separately from it not having special characters, as well as from the password needing to have certain
requirements. A misspelled (or missing) field in a config can be validated separately from another field not being
well-formed.</p>

<p>Enter <code class="highlighter-rouge">Validated</code>.</p>

<h2 id="parallel-validation">Parallel validation</h2>
<p>Our goal is to report any and all errors across independent bits of data. For instance, when we ask for several
pieces of configuration, each configuration field can be validated separately from one another. How then do we
enforce that the data we are working with is independent? We ask for both of them up front.</p>

<p>As our running example, we will look at config parsing. Our config will be represented by a
<code class="highlighter-rouge">Map[String, String]</code>. Parsing will be handled by a <code class="highlighter-rouge">Read</code> type class - we provide instances
just for <code class="highlighter-rouge">String</code> and <code class="highlighter-rouge">Int</code> for brevity.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Read</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">read</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Read</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Read</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Read</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">A</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="n">stringRead</span><span class="k">:</span> <span class="kt">Read</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Read</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">read</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="n">intRead</span><span class="k">:</span> <span class="kt">Read</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Read</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">read</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="s">"-?[0-9]+"</span><span class="o">))</span> <span class="nc">Some</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">toInt</span><span class="o">)</span>
        <span class="k">else</span> <span class="nc">None</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Then we enumerate our errors - when asking for a config value, one of two things can
go wrong: the field is missing, or it is not well-formed with regards to the expected
type.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">ConfigError</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">MissingConfig</span><span class="o">(</span><span class="n">field</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ConfigError</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">ParseError</span><span class="o">(</span><span class="n">field</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ConfigError</span>
</code></pre>
</div>

<p>We need a data type that can represent either a successful value (a parsed configuration),
or an error.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Validated</span><span class="o">[</span><span class="kt">+E</span>, <span class="kt">+A</span><span class="o">]</span>

<span class="nc">object</span> <span class="nc">Validated</span> <span class="o">{</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Valid</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Validated</span><span class="o">[</span><span class="kt">Nothing</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Invalid</span><span class="o">[</span><span class="kt">+E</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">Nothing</span><span class="o">]</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Now we are ready to write our parser.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.Validated</span>
<span class="k">import</span> <span class="nn">cats.data.Validated.</span><span class="o">{</span><span class="nc">Invalid</span><span class="o">,</span> <span class="nc">Valid</span><span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Config</span><span class="o">(</span><span class="n">map</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">parse</span><span class="o">[</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Read</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Validated</span><span class="o">[</span><span class="kt">ConfigError</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">map</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">None</span>        <span class="k">=&gt;</span> <span class="nc">Invalid</span><span class="o">(</span><span class="nc">MissingConfig</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>
      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nc">Read</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="n">read</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">None</span>    <span class="k">=&gt;</span> <span class="nc">Invalid</span><span class="o">(</span><span class="nc">ParseError</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>
          <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Valid</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Everything is in place to write the parallel validator. Recall that we can only do parallel
validation if each piece is independent. How do we enforce the data is independent? By asking
for all of it up front. Let’s start with two pieces of data.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">parallelValidate</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">v1</span><span class="k">:</span> <span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">],</span> <span class="n">v2</span><span class="k">:</span> <span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">Valid</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="nc">Valid</span><span class="o">(</span><span class="n">b</span><span class="o">))</span>       <span class="k">=&gt;</span> <span class="nc">Valid</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">Valid</span><span class="o">(</span><span class="k">_</span><span class="o">),</span> <span class="n">i</span><span class="nd">@Invalid</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>   <span class="k">=&gt;</span> <span class="n">i</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">i</span><span class="nd">@Invalid</span><span class="o">(</span><span class="k">_</span><span class="o">),</span> <span class="nc">Valid</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>   <span class="k">=&gt;</span> <span class="n">i</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">Invalid</span><span class="o">(</span><span class="n">e1</span><span class="o">),</span> <span class="nc">Invalid</span><span class="o">(</span><span class="n">e2</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="o">???</span>
  <span class="o">}</span>
</code></pre>
</div>

<p>We’ve run into a problem. In the case where both have errors, we want to report both. But we have
no way of combining the two errors into one error! Perhaps we can put both errors into a <code class="highlighter-rouge">List</code>,
but that seems needlessly specific - clients may want to define their own way of combining errors.</p>

<p>How then do we abstract over a binary operation? The <code class="highlighter-rouge">Semigroup</code> type class captures this idea.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Semigroup</span>

<span class="k">def</span> <span class="n">parallelValidate</span><span class="o">[</span><span class="kt">E</span> <span class="kt">:</span> <span class="kt">Semigroup</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">v1</span><span class="k">:</span> <span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">],</span> <span class="n">v2</span><span class="k">:</span> <span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">Valid</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="nc">Valid</span><span class="o">(</span><span class="n">b</span><span class="o">))</span>       <span class="k">=&gt;</span> <span class="nc">Valid</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">Valid</span><span class="o">(</span><span class="k">_</span><span class="o">),</span> <span class="n">i</span><span class="nd">@Invalid</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>   <span class="k">=&gt;</span> <span class="n">i</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">i</span><span class="nd">@Invalid</span><span class="o">(</span><span class="k">_</span><span class="o">),</span> <span class="nc">Valid</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>   <span class="k">=&gt;</span> <span class="n">i</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">Invalid</span><span class="o">(</span><span class="n">e1</span><span class="o">),</span> <span class="nc">Invalid</span><span class="o">(</span><span class="n">e2</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Invalid</span><span class="o">(</span><span class="nc">Semigroup</span><span class="o">[</span><span class="kt">E</span><span class="o">].</span><span class="n">combine</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre>
</div>

<p>Perfect! But.. going back to our example, we don’t have a way to combine <code class="highlighter-rouge">ConfigError</code>s. But as clients,
we can change our <code class="highlighter-rouge">Validated</code> values where the error can be combined, say, a <code class="highlighter-rouge">List[ConfigError]</code>. It is
more common however to use a <code class="highlighter-rouge">NonEmptyList[ConfigError]</code> - the <code class="highlighter-rouge">NonEmptyList</code> statically guarantees we
have at least one value, which aligns with the fact that if we have an <code class="highlighter-rouge">Invalid</code>, then we most
certainly have at least one error. This technique is so common there is a convenient method on <code class="highlighter-rouge">Validated</code>
called <code class="highlighter-rouge">toValidatedNel</code> that turns any <code class="highlighter-rouge">Validated[E, A]</code> value to a <code class="highlighter-rouge">Validated[NonEmptyList[E], A]</code>.
Additionally, the type alias <code class="highlighter-rouge">ValidatedNel[E, A]</code> is provided.</p>

<p>Time to parse.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.SemigroupK</span>
<span class="k">import</span> <span class="nn">cats.data.NonEmptyList</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">ConnectionParams</span><span class="o">(</span><span class="n">url</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">port</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">val</span> <span class="n">config</span> <span class="k">=</span> <span class="nc">Config</span><span class="o">(</span><span class="nc">Map</span><span class="o">((</span><span class="s">"endpoint"</span><span class="o">,</span> <span class="s">"127.0.0.1"</span><span class="o">),</span> <span class="o">(</span><span class="s">"port"</span><span class="o">,</span> <span class="s">"not an int"</span><span class="o">)))</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">nelSemigroup</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">ConfigError</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">SemigroupK</span><span class="o">[</span><span class="kt">NonEmptyList</span><span class="o">].</span><span class="n">algebra</span><span class="o">[</span><span class="kt">ConfigError</span><span class="o">]</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">readString</span><span class="k">:</span> <span class="kt">Read</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Read</span><span class="o">.</span><span class="n">stringRead</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">readInt</span><span class="k">:</span> <span class="kt">Read</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Read</span><span class="o">.</span><span class="n">intRead</span>
</code></pre>
</div>

<p>Any and all errors are reported!</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">v1</span> <span class="k">=</span> <span class="n">parallelValidate</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="n">parse</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"url"</span><span class="o">).</span><span class="n">toValidatedNel</span><span class="o">,</span>
                          <span class="n">config</span><span class="o">.</span><span class="n">parse</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"port"</span><span class="o">).</span><span class="n">toValidatedNel</span><span class="o">)(</span><span class="nc">ConnectionParams</span><span class="o">.</span><span class="n">apply</span><span class="o">)</span>
<span class="c1">// v1: cats.data.Validated[cats.data.NonEmptyList[ConfigError],ConnectionParams] = Invalid(NonEmptyList(MissingConfig(url), ParseError(port)))
</span>
<span class="k">val</span> <span class="n">v2</span> <span class="k">=</span> <span class="n">parallelValidate</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="n">parse</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"endpoint"</span><span class="o">).</span><span class="n">toValidatedNel</span><span class="o">,</span>
                          <span class="n">config</span><span class="o">.</span><span class="n">parse</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"port"</span><span class="o">).</span><span class="n">toValidatedNel</span><span class="o">)(</span><span class="nc">ConnectionParams</span><span class="o">.</span><span class="n">apply</span><span class="o">)</span>
<span class="c1">// v2: cats.data.Validated[cats.data.NonEmptyList[ConfigError],ConnectionParams] = Invalid(NonEmptyList(ParseError(port)))
</span>
<span class="k">val</span> <span class="n">config</span> <span class="k">=</span> <span class="nc">Config</span><span class="o">(</span><span class="nc">Map</span><span class="o">((</span><span class="s">"endpoint"</span><span class="o">,</span> <span class="s">"127.0.0.1"</span><span class="o">),</span> <span class="o">(</span><span class="s">"port"</span><span class="o">,</span> <span class="s">"1234"</span><span class="o">)))</span>
<span class="c1">// config: Config = Config(Map(endpoint -&gt; 127.0.0.1, port -&gt; 1234))
</span>
<span class="k">val</span> <span class="n">v3</span> <span class="k">=</span> <span class="n">parallelValidate</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="n">parse</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"endpoint"</span><span class="o">).</span><span class="n">toValidatedNel</span><span class="o">,</span>
                          <span class="n">config</span><span class="o">.</span><span class="n">parse</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"port"</span><span class="o">).</span><span class="n">toValidatedNel</span><span class="o">)(</span><span class="nc">ConnectionParams</span><span class="o">.</span><span class="n">apply</span><span class="o">)</span>
<span class="c1">// v3: cats.data.Validated[cats.data.NonEmptyList[ConfigError],ConnectionParams] = Valid(ConnectionParams(127.0.0.1,1234))
</span></code></pre>
</div>

<h2 id="apply">Apply</h2>
<p>Our <code class="highlighter-rouge">parallelValidate</code> function looks awfully like the <code class="highlighter-rouge">Apply#map2</code> function.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">map2</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span>
</code></pre>
</div>

<p>Which can be defined in terms of <code class="highlighter-rouge">Apply#ap</code> and <code class="highlighter-rouge">Apply#map</code>, the very functions needed to create an <code class="highlighter-rouge">Apply</code> instance.</p>

<p>Can we perhaps define an <code class="highlighter-rouge">Apply</code> instance for <code class="highlighter-rouge">Validated</code>? Better yet, can we define an <code class="highlighter-rouge">Applicative</code> instance?</p>

<p><em>Note</em>: the example below assumes usage of the <a href="https://github.com/non/kind-projector">kind-projector compiler plugin</a> and will not compile if it is not being used in a project.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Applicative</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="n">validatedApplicative</span><span class="o">[</span><span class="kt">E</span> <span class="kt">:</span> <span class="kt">Semigroup</span><span class="o">]</span><span class="k">:</span> <span class="kt">Applicative</span><span class="o">[</span><span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">ap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="o">(</span><span class="n">fa</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="o">(</span><span class="nc">Valid</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="nc">Valid</span><span class="o">(</span><span class="n">fab</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Valid</span><span class="o">(</span><span class="n">fab</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
        <span class="k">case</span> <span class="o">(</span><span class="n">i</span><span class="nd">@Invalid</span><span class="o">(</span><span class="k">_</span><span class="o">),</span> <span class="nc">Valid</span><span class="o">(</span><span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">i</span>
        <span class="k">case</span> <span class="o">(</span><span class="nc">Valid</span><span class="o">(</span><span class="k">_</span><span class="o">),</span> <span class="n">i</span><span class="nd">@Invalid</span><span class="o">(</span><span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">i</span>
        <span class="k">case</span> <span class="o">(</span><span class="nc">Invalid</span><span class="o">(</span><span class="n">e1</span><span class="o">),</span> <span class="nc">Invalid</span><span class="o">(</span><span class="n">e2</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Invalid</span><span class="o">(</span><span class="nc">Semigroup</span><span class="o">[</span><span class="kt">E</span><span class="o">].</span><span class="n">combine</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">))</span>
      <span class="o">}</span>

    <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Validated</span><span class="o">.</span><span class="n">valid</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre>
</div>

<p>Awesome! And now we also get access to all the goodness of <code class="highlighter-rouge">Applicative</code>, which includes <code class="highlighter-rouge">map{2-22}</code>, as well as the
<code class="highlighter-rouge">Cartesian</code> syntax <code class="highlighter-rouge">|@|</code>.</p>

<p>We can now easily ask for several bits of configuration and get any and all errors returned back.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Apply</span>
<span class="k">import</span> <span class="nn">cats.data.ValidatedNel</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">nelSemigroup</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">ConfigError</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">SemigroupK</span><span class="o">[</span><span class="kt">NonEmptyList</span><span class="o">].</span><span class="n">algebra</span><span class="o">[</span><span class="kt">ConfigError</span><span class="o">]</span>

<span class="k">val</span> <span class="n">config</span> <span class="k">=</span> <span class="nc">Config</span><span class="o">(</span><span class="nc">Map</span><span class="o">((</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"cat"</span><span class="o">),</span> <span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="s">"not a number"</span><span class="o">),</span> <span class="o">(</span><span class="s">"houseNumber"</span><span class="o">,</span> <span class="s">"1234"</span><span class="o">),</span> <span class="o">(</span><span class="s">"lane"</span><span class="o">,</span> <span class="s">"feline street"</span><span class="o">)))</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Address</span><span class="o">(</span><span class="n">houseNumber</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">street</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">address</span><span class="k">:</span> <span class="kt">Address</span><span class="o">)</span>
</code></pre>
</div>

<p>Thus.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">personFromConfig</span><span class="k">:</span> <span class="kt">ValidatedNel</span><span class="o">[</span><span class="kt">ConfigError</span>, <span class="kt">Person</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Apply</span><span class="o">[</span><span class="kt">ValidatedNel</span><span class="o">[</span><span class="kt">ConfigError</span>, <span class="kt">?</span><span class="o">]].</span><span class="n">map4</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="n">parse</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"name"</span><span class="o">).</span><span class="n">toValidatedNel</span><span class="o">,</span>
                                           <span class="n">config</span><span class="o">.</span><span class="n">parse</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"age"</span><span class="o">).</span><span class="n">toValidatedNel</span><span class="o">,</span>
                                           <span class="n">config</span><span class="o">.</span><span class="n">parse</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"house_number"</span><span class="o">).</span><span class="n">toValidatedNel</span><span class="o">,</span>
                                           <span class="n">config</span><span class="o">.</span><span class="n">parse</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"street"</span><span class="o">).</span><span class="n">toValidatedNel</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">,</span> <span class="n">houseNumber</span><span class="o">,</span> <span class="n">street</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">,</span> <span class="nc">Address</span><span class="o">(</span><span class="n">houseNumber</span><span class="o">,</span> <span class="n">street</span><span class="o">))</span>
  <span class="o">}</span>
<span class="c1">// personFromConfig: cats.data.ValidatedNel[ConfigError,Person] = Invalid(NonEmptyList(MissingConfig(street), MissingConfig(house_number), ParseError(age)))
</span></code></pre>
</div>

<h2 id="of-flatmaps-and-eithers">Of <code class="highlighter-rouge">flatMap</code>s and <code class="highlighter-rouge">Either</code>s</h2>
<p><code class="highlighter-rouge">Option</code> has <code class="highlighter-rouge">flatMap</code>, <code class="highlighter-rouge">Either</code> has <code class="highlighter-rouge">flatMap</code>, where’s <code class="highlighter-rouge">Validated</code>’s? Let’s try to implement it - better yet,
let’s implement the <code class="highlighter-rouge">Monad</code> type class.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Monad</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="n">validatedMonad</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Valid</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>     <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
        <span class="k">case</span> <span class="n">i</span><span class="nd">@Invalid</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">i</span>
      <span class="o">}</span>

    <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Valid</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

    <span class="nd">@annotation</span><span class="o">.</span><span class="n">tailrec</span>
    <span class="k">def</span> <span class="n">tailRecM</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Validated</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Valid</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Valid</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">Valid</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">tailRecM</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
        <span class="k">case</span> <span class="n">i</span><span class="nd">@Invalid</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">i</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre>
</div>

<p>Note that all <code class="highlighter-rouge">Monad</code> instances are also <code class="highlighter-rouge">Applicative</code> instances, where <code class="highlighter-rouge">ap</code> is defined as</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">flatMap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">.</span><span class="n">andThen</span><span class="o">(</span><span class="n">pure</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">ap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">flatMap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">fab</span> <span class="k">=&gt;</span> <span class="n">fab</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>
<span class="o">}</span>
</code></pre>
</div>

<p>However, the <code class="highlighter-rouge">ap</code> behavior defined in terms of <code class="highlighter-rouge">flatMap</code> does not behave the same as that of
our <code class="highlighter-rouge">ap</code> defined above. Observe:</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="n">validatedMonad</span><span class="o">.</span><span class="n">tuple2</span><span class="o">(</span><span class="nc">Validated</span><span class="o">.</span><span class="n">invalidNel</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">](</span><span class="s">"oops"</span><span class="o">),</span> <span class="nc">Validated</span><span class="o">.</span><span class="n">invalidNel</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Double</span><span class="o">](</span><span class="s">"uh oh"</span><span class="o">))</span>
<span class="c1">// v: cats.data.Validated[cats.data.NonEmptyList[String],(Int, Double)] = Invalid(NonEmptyList(oops))
</span></code></pre>
</div>

<p>This one short circuits! Therefore, if we were to define a <code class="highlighter-rouge">Monad</code> (or <code class="highlighter-rouge">FlatMap</code>) instance for <code class="highlighter-rouge">Validated</code> we would
have to override <code class="highlighter-rouge">ap</code> to get the behavior we want. But then the behavior of <code class="highlighter-rouge">flatMap</code> would be inconsistent with
that of <code class="highlighter-rouge">ap</code>, not good. Therefore, <code class="highlighter-rouge">Validated</code> has only an <code class="highlighter-rouge">Applicative</code> instance.</p>

<h2 id="validated-vs-either"><code class="highlighter-rouge">Validated</code> vs <code class="highlighter-rouge">Either</code></h2>

<p>We’ve established that an error-accumulating data type such as <code class="highlighter-rouge">Validated</code> can’t have a valid <code class="highlighter-rouge">Monad</code> instance. Sometimes the task at hand requires error-accumulation. However, sometimes we want a monadic structure that we can use for sequential validation (such as in a for-comprehension). This leaves us in a bit of a conundrum.</p>

<p>Cats has decided to solve this problem by using separate data structures for error-accumulation (<code class="highlighter-rouge">Validated</code>) and short-circuiting monadic behavior (<code class="highlighter-rouge">Either</code>).</p>

<p>If you are trying to decide whether you want to use <code class="highlighter-rouge">Validated</code> or <code class="highlighter-rouge">Either</code>, a simple heuristic is to use <code class="highlighter-rouge">Validated</code> if you want error-accumulation and to otherwise use <code class="highlighter-rouge">Either</code>.</p>

<h2 id="sequential-validation">Sequential Validation</h2>

<p>If you do want error accumulation but occasionally run into places where you sequential validation is needed, then <code class="highlighter-rouge">Validated</code> provides a couple methods that may be helpful.</p>

<h3 id="andthen"><code class="highlighter-rouge">andThen</code></h3>
<p>The <code class="highlighter-rouge">andThen</code> method is similar to <code class="highlighter-rouge">flatMap</code> (such as <code class="highlighter-rouge">Either.flatMap</code>). In the cause of success, it passes the valid value into a function that returns a new <code class="highlighter-rouge">Validated</code> instance.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">houseNumber</span> <span class="k">=</span> <span class="n">config</span><span class="o">.</span><span class="n">parse</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"house_number"</span><span class="o">).</span><span class="n">andThen</span><span class="o">{</span> <span class="n">n</span> <span class="k">=&gt;</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">Validated</span><span class="o">.</span><span class="n">valid</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
   <span class="k">else</span> <span class="nc">Validated</span><span class="o">.</span><span class="n">invalid</span><span class="o">(</span><span class="nc">ParseError</span><span class="o">(</span><span class="s">"house_number"</span><span class="o">))</span>
<span class="o">}</span>
<span class="c1">// houseNumber: cats.data.Validated[ConfigError,Int] = Invalid(MissingConfig(house_number))
</span></code></pre>
</div>

<h3 id="witheither"><code class="highlighter-rouge">withEither</code></h3>
<p>The <code class="highlighter-rouge">withEither</code> method allows you to temporarily turn a <code class="highlighter-rouge">Validated</code> instance into an <code class="highlighter-rouge">Either</code> instance and apply it to a function.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.syntax.either._</span> <span class="c1">// get Either#flatMap
</span>
<span class="k">def</span> <span class="n">positive</span><span class="o">(</span><span class="n">field</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">ConfigError</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">Right</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="k">else</span> <span class="nc">Left</span><span class="o">(</span><span class="nc">ParseError</span><span class="o">(</span><span class="n">field</span><span class="o">))</span>
<span class="o">}</span>
</code></pre>
</div>

<p>Thus.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">houseNumber</span> <span class="k">=</span> <span class="n">config</span><span class="o">.</span><span class="n">parse</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"house_number"</span><span class="o">).</span><span class="n">withEither</span><span class="o">{</span> <span class="n">either</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">ConfigError</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span>
  <span class="n">either</span><span class="o">.</span><span class="n">flatMap</span><span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
    <span class="n">positive</span><span class="o">(</span><span class="s">"house_number"</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// houseNumber: cats.data.Validated[ConfigError,Int] = Invalid(MissingConfig(house_number))
</span></code></pre>
</div>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/scala.min.js"></script><script src="/cats/js/main.js"></script></body></html>